// Generated by CoffeeScript 1.10.0
(function() {
  var Lines, Stream, cell, line, terminalColor,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Stream = require('stream');

  cell = require('./cell');

  line = require('./line');

  terminalColor = require('./color');

  Lines = (function(superClass) {
    extend(Lines, superClass);

    function Lines() {
      Lines.__super__.constructor.call(this);
      this._lines = [];
    }

    Lines.prototype._read = function() {};

    Lines.prototype.flush = function() {
      return this.push(this.toString());
    };

    Lines.prototype.line = function() {
      this._lines = this._lines.concat([line.apply(null, arguments)]);
      return this;
    };

    Lines.prototype.box = function() {
      var color, from, ref, style, to;
      if (arguments.length === 1) {
        ref = arguments[0], from = ref.from, to = ref.to, style = ref.style, color = ref.color;
      } else {
        from = arguments[0];
        to = arguments[1];
        style = arguments[2];
        color = arguments[3];
      }
      this.line({
        from: from,
        to: [from[0], to[1]],
        style: style,
        color: color
      });
      this.line({
        from: [from[0], to[1]],
        to: to,
        style: style,
        color: color
      });
      this.line({
        from: to,
        to: [to[0], from[1]],
        style: style,
        color: color
      });
      this.line({
        from: [to[0], from[1]],
        to: from,
        style: style,
        color: color
      });
      return this;
    };

    Lines.prototype.lines = function() {
      return this._lines;
    };

    Lines.prototype.toString = function() {
      var buffers, col, cols, currentColor, down, i, j, k, l, left, len, lines, ref, ref1, ref2, ref3, right, row, rows, stringVal, up;
      lines = this.lines();
      cols = Math.max(Math.max.apply(null, lines.map(function(l) {
        return l.from[0];
      })), Math.max.apply(null, lines.map(function(l) {
        return l.to[0];
      })));
      rows = Math.max(Math.max.apply(null, lines.map(function(l) {
        return l.from[1];
      })), Math.max.apply(null, lines.map(function(l) {
        return l.to[1];
      })));
      buffers = (function() {
        var i, ref, results;
        results = [];
        for (row = i = 0, ref = rows; 0 <= ref ? i <= ref : i >= ref; row = 0 <= ref ? ++i : --i) {
          results.push((function() {
            var j, ref1, results1;
            results1 = [];
            for (col = j = 0, ref1 = cols; 0 <= ref1 ? j <= ref1 : j >= ref1; col = 0 <= ref1 ? ++j : --j) {
              results1.push(cell());
            }
            return results1;
          })());
        }
        return results;
      })();
      for (i = 0, len = lines.length; i < len; i++) {
        l = lines[i];
        switch (true) {
          case l.horizontal():
            left = Math.min(l.from[0], l.to[0]);
            right = Math.max(l.from[0], l.to[0]);
            row = buffers[l.from[1]];
            row[left].right(l.style, l.color);
            row[right].left(l.style, l.color);
            for (col = j = ref = left + 1, ref1 = right; ref <= ref1 ? j < ref1 : j > ref1; col = ref <= ref1 ? ++j : --j) {
              row[col].left(l.style, l.color);
              row[col].right(l.style, l.color);
            }
            break;
          case l.vertical():
            up = Math.min(l.from[1], l.to[1]);
            down = Math.max(l.from[1], l.to[1]);
            col = l.from[0];
            buffers[up][col].down(l.style, l.color);
            buffers[down][col].up(l.style, l.color);
            for (row = k = ref2 = up + 1, ref3 = down; ref2 <= ref3 ? k < ref3 : k > ref3; row = ref2 <= ref3 ? ++k : --k) {
              buffers[row][col].up(l.style, l.color);
              buffers[row][col].down(l.style, l.color);
            }
        }
      }
      currentColor = {
        foreground: 'none',
        background: 'none'
      };
      stringVal = buffers.map(function(buffer) {
        return buffer.map(function(cell) {
          var back, char, color, fore, output, ref4;
          ref4 = cell.toString(), char = ref4.char, color = ref4.color;
          output = char;
          if (char !== ' ') {
            fore = color.foreground, back = color.background;
            if (fore && fore !== currentColor.foreground) {
              currentColor.foreground = fore;
              output = terminalColor.foreground(fore) + output;
            }
            if (back && back !== currentColor.background) {
              currentColor.background = back;
              output = terminalColor.background(back) + output;
            }
          }
          return output;
        }).join('');
      }).join('\n');
      if (currentColor.foreground !== 'none') {
        stringVal += terminalColor.foreground('none');
      }
      if (currentColor.background !== 'none') {
        stringVal += terminalColor.background('none');
      }
      return stringVal;
    };

    return Lines;

  })(Stream.Readable);

  module.exports = function() {
    return new Lines();
  };

}).call(this);
